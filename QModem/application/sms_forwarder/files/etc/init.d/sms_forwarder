#!/bin/sh /etc/rc.common

START=90
STOP=10

USE_PROCD=1
PROG=/usr/bin/sms_forwarder

start_service() {
	config_load sms_daemon
	
	local enabled
	config_get_bool enabled sms_forward enable 0
	
	if [ "$enabled" -eq 0 ]; then
		echo "SMS Forward service is disabled"
		return 0
	fi
	
	# Generate combined configuration file
	local config_file="/tmp/sms_forwarder_combined.json"
	generate_combined_config "$config_file"
	
	if [ $? -ne 0 ]; then
		echo "Error: Failed to generate combined configuration"
		return 1
	fi
	
	# Start single SMS forwarder instance with combined config
	procd_open_instance "sms_forwarder"
	procd_set_param command "$PROG" "$config_file"
	procd_set_param respawn
	procd_set_param stdout 1
	procd_set_param stderr 1
	procd_set_param file "$config_file"
	procd_close_instance
}

generate_combined_config() {
	local config_file="$1"
	local temp_file="/tmp/sms_modem_configs.tmp"
	
	# Clear temp file
	> "$temp_file"
	
	# Collect all modem configurations
	config_foreach collect_modem_config sms_forward_instance "$temp_file"
	
	if [ ! -s "$temp_file" ]; then
		echo "Error: No valid SMS forward instances found"
		return 1
	fi
	
	# Merge configurations by modem_port and generate final JSON
	merge_and_generate_json "$temp_file" "$config_file"
	local result=$?
	
	# Clean up temp file
	rm -f "$temp_file"
	
	# Validate the generated JSON
	if command -v jq >/dev/null 2>&1; then
		if ! jq . "$config_file" >/dev/null 2>&1; then
			echo "Error: Generated JSON config is invalid"
			echo "Config file content:"
			cat "$config_file"
			return 1
		fi
	fi
	
	return $result
}

collect_modem_config() {
	local section="$1"
	local temp_file="$2"
	local enabled port poll_interval delete_after_forward api_type
	
	config_get_bool enabled "$section" enable 0
	[ "$enabled" -eq 0 ] && return 0
	
	config_get port "$section" listen_port
	config_get poll_interval "$section" poll_interval 30
	config_get_bool delete_after_forward "$section" delete_after_forward 0
	config_get api_type "$section" api_type
	
	# Validate required parameters
	[ -z "$port" ] && {
		echo "Error: No modem port specified for instance $section"
		return 1
	}
	
	[ -z "$api_type" ] && {
		echo "Error: No API type specified for instance $section"
		return 1
	}
	
	# Generate API config based on type
	local api_config=$(generate_api_config "$section" "$api_type")
	if [ -z "$api_config" ]; then
		echo "Error: Failed to generate API config for $api_type in instance $section"
		return 1
	fi
	
	# Write config line to temp file: PORT|POLL_INTERVAL|DELETE_FLAG|API_TYPE|API_CONFIG
	echo "${port}|${poll_interval}|${delete_after_forward}|${api_type}|${api_config}" >> "$temp_file"
}

merge_and_generate_json() {
	local temp_file="$1"
	local config_file="$2"
	local first_modem=1
	
	# Start JSON array
	echo "[" > "$config_file"
	
	# Get unique modem ports
	local unique_ports=$(cut -d'|' -f1 "$temp_file" | sort -u)
	
	for port in $unique_ports; do
		# Add comma if not first modem
		if [ "$first_modem" -eq 0 ]; then
			echo "," >> "$config_file"
		fi
		first_modem=0
		
		# Find all configs for this port
		local port_configs_file="/tmp/port_configs_${port//\//_}.tmp"
		grep "^${port}|" "$temp_file" > "$port_configs_file"
		
		# Get common settings from first config for this port
		local first_line=$(head -n1 "$port_configs_file")
		local poll_interval=$(echo "$first_line" | cut -d'|' -f2)
		local delete_after_forward=$(echo "$first_line" | cut -d'|' -f3)
		
		# Start modem configuration object
		printf '{\n\t"modem_port": "%s",\n\t"poll_interval": %d,\n\t"delete_after_forward": %s,\n\t"apis": [\n' \
			"$port" "$poll_interval" "$delete_after_forward" >> "$config_file"
		
		# Add all APIs for this port
		local first_api=1
		while IFS='|' read -r p_port p_poll p_delete p_api_type p_api_config; do
			# Add comma if not first API
			if [ "$first_api" -eq 0 ]; then
				echo "," >> "$config_file"
			fi
			first_api=0
			
			# Add API configuration
			printf '\t\t{\n\t\t\t"api_type": "%s",\n\t\t\t"api_config": %s\n\t\t}' \
				"$p_api_type" "$p_api_config" >> "$config_file"
		done < "$port_configs_file"
		
		# Clean up temp file
		rm -f "$port_configs_file"
		
		# End apis array and modem object
		printf '\n\t]\n}' >> "$config_file"
	done
	
	# End JSON array
	echo "" >> "$config_file"
	echo "]" >> "$config_file"
}

generate_api_config() {
	local section="$1"
	local api_type="$2"
	local config_json=""
	
	case "$api_type" in
		"tgbot")
			local bot_token chat_id
			config_get bot_token "$section" tg_bot_token
			config_get chat_id "$section" tg_chat_id
			
			[ -z "$bot_token" ] || [ -z "$chat_id" ] && {
				echo "Error: Telegram Bot requires bot_token and chat_id"
				return 1
			}
			
			config_json="{\"bot_token\":\"$bot_token\",\"chat_id\":\"$chat_id\"}"
			;;
			
		"webhook")
			local webhook_url headers format request_method format_escaped
			config_get webhook_url "$section" webhook_url
			config_get headers "$section" webhook_headers
			config_get format "$section" webhook_format
			config_get request_method "$section" webhook_request_method
			
			[ -z "$webhook_url" ] && {
				echo "Error: Webhook requires webhook_url"
				return 1
			}
			
			# Escape format string for JSON using awk (safe for all special characters)
			if [ -n "$format" ]; then
				format_escaped=$(printf '%s' "$format" | awk '
				{
					gsub(/\\/, "\\\\")
					gsub(/"/, "\\\"")
					gsub(/\t/, "\\t")
					gsub(/\r/, "\\r")
					gsub(/\n/, "\\n")
					printf "%s", $0
				}
				END {
					if (NR > 0) printf "\\n"
				}' | sed 's/\\n$//')
			fi
			
			if [ -n "$headers" ]; then
				config_json="{\"webhook_url\":\"$webhook_url\",\"headers\":\"$headers\",\"format\":\"$format_escaped\",\"request_method\":\"$request_method\"}"
			else
				config_json="{\"webhook_url\":\"$webhook_url\",\"format\":\"$format_escaped\",\"request_method\":\"$request_method\"}"
			fi
			;;
			
		"serverchan")
			local token channel noip openid
			config_get token "$section" serverchan_token
			config_get channel "$section" serverchan_channel
			config_get noip "$section" serverchan_noip
			config_get openid "$section" serverchan_openid
			
			[ -z "$token" ] && {
				echo "Error: ServerChan requires token"
				return 1
			}
			
			config_json="{\"token\":\"$token\""
			[ -n "$channel" ] && config_json="$config_json,\"channel\":\"$channel\""
			[ "$noip" = "1" ] && config_json="$config_json,\"noip\":\"1\""
			[ -n "$openid" ] && config_json="$config_json,\"openid\":\"$openid\""
			config_json="$config_json}"
			;;
			
		"pushdeer")
			local push_key endpoint
			config_get push_key "$section" pushdeer_push_key
			config_get endpoint "$section" pushdeer_endpoint
			
			[ -z "$push_key" ] && {
				echo "Error: PushDeer requires push_key"
				return 1
			}
			
			config_json="{\"push_key\":\"$push_key\""
			[ -n "$endpoint" ] && config_json="$config_json,\"endpoint\":\"$endpoint\""
			config_json="$config_json}"
			;;
		"feishu")
			local webhook_key
			config_get webhook_key "$section" feishu_webhook_key
			
			[ -z "$webhook_key" ] && {
				echo "Error: Feishu requires webhook_key"
				return 1
			}
			
			config_json="{\"webhook_key\":\"$webhook_key\"}"
			;;
		"custom_script")
			local script_path
			config_get script_path "$section" custom_script_path
			
			[ -z "$script_path" ] && {
				echo "Error: Custom script requires script_path"
				return 1
			}
			
			config_json="{\"script_path\":\"$script_path\"}"
			;;
			
		*)
			echo "Error: Unknown API type: $api_type"
			return 1
			;;
	esac
	
	echo "$config_json"
}

service_triggers() {
	procd_add_reload_trigger "sms_daemon"
}
